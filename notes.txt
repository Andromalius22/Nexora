resources up to T4 can be found in planetsor giant gasses planets. above, they are found in stars, black holes, asteroids belt, or even deep space.
hyperfluids 
    are gathered with Flux nets : magnetic funnels that freeze plasma threads into semi-stable strands.
    Condensation: the strands are injected into phase cryochambers containing Alloy-Gas catalysts (T3 materials).
    Resonant Seeding: special oscillating fields cause particle coherence to cascade — the “hyperphase.”
    Stabilization: cooled within Quantum Alloy containers lined with Biopolymer membranes that adapt to field fluctuations.
    Other trivia :
        Each batch behaves uniquely — alive in a sense. Hyperfluid “ages” and develops resonance patterns based on its handling history, leading to cultural myths of temperamental batches.
        Key ingredient for high-tech modules and infrastructure (e.g. “Hypergrid Networks”).
        High market volatility — certain stars output rare isotopic variants.
        Requires multifaction cooperation: gas miners (for raw plasma), alloy refiners (for containment), and biotech producers (for membranes).
        Acts as both a strategic resource and a logistical challenge — transporting it safely is risky.
    Industrial Applications:
        Energy Conduits: zero-loss transmission lines between orbital stations.
        Data Lattice Fluidics: allows processors to be built in liquid form; ships literally think through fluid motion.
        Propulsion Medium: used in Hyperstream Drives, where fluid resonance amplifies thrust efficiency by bending local spacetime drag.
        Cloaking Systems: the Quantum Vapor and early Hyperfluid variants are used for refractive field modulation.
        AI Core Substrate: sentient AIs are “grown” in Hyperfluid baths that host their neural lattices.
    
- 'space_structures.json' holds all template data for buildable space structures: id, name, hp, cost, abilities, etc.
- Use: from assetsmanager import load_space_structures; structs = load_space_structures()
- Each is returned as SpaceStructure class (see assetsmanager.py)
    
Industry-per-defense for Ion Cannon = 500 industry / 80 defense_value = 6.25 industry per defense_value
Basic Farm (T1 crop fields): 30 Organifera / min

Hydroponic Farm (upgraded building): 60 Organifera / min

Advanced Biofarm (high-tech, requires T2 raw): 12 Organifera II / min (produces T2 organics rather than T1)

Symbiotic Vats (T3 production): 4 Symbiotic Culture / min

Wetware Labs (T4 production): 1–2 Neural Biomass / min

Example processing recipes and rates:

Raw Organifera → Nutrient Gel: 5 Organifera → 3 Nutrient Gel, processing takes 1 min (i.e., a single processor converts 15 Organifera/min → 9 Nutrient Gel/min).

Organifera II → BioComposite: 4 OII → 1 BioComposite / min (low-volume, higher value).

Symbiotic Culture → BioCatalyst: 3 → 1 / min.

Neural Biomass → Wetware Core: 10 → 1 every 2 min (very slow, high value).

Measure performances issues :
    import time
    start = time.perf_counter()
    for planet in player.planets:
        planet.resources.apply_decay(delta_hours=1)
    print("Decay tick:", time.perf_counter() - start)

######################################################################################################################

⚙️ Option 3 — Schedule tasks via asyncio.create_task

For more dynamic systems (if you want to pause or reschedule), you can spawn periodic tasks:

async def update_game_state(self):
    asyncio.create_task(self._tick_builds())
    asyncio.create_task(self._tick_resources())

async def _tick_builds(self):
    while True:
        await asyncio.sleep(1)
        # ...

async def _tick_resources(self):
    while True:
        await asyncio.sleep(60)
        # ...
This is a bit more flexible if you ever need to restart or throttle subsystems dynamically (e.g. in response to load).

########################################################################################################################
If you want, I can also show a delta-saving approach, 
where only modified galaxies are serialized per player — this reduces file size and write load for big galaxies
########################################################################################################################
from core.galaxy.galaxy_map import GalaxyMap
from core.player import Player

player = Player(id="local_001", name="Commander")
galaxy = GalaxyMap.generate_for_player(player)
########################################################################################################################
GIF 
Consider using sprite sheets for even better memory efficiency
########################################################################################################################